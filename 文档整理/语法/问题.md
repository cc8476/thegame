


    //tech points:
    //scene ,destroy and create  ***
    //arrange the relationship of class [player, fightAction, item,equipment,fight,team of player, user]
    //mouseevent ,click and show dialog or panes   ***
    //local database ***




    //design all the scenes
    //1.begin scene : start button, continue ,intro 
    //2.intro scene: title , intro text, designer,programer:413802172@qq.com
    //3.town scene: getplayer,item ,equip
    //3.1-3.3 getplayer pane,item pane,equip pane
    //4.routine scene:choose enemy teams or events
    //5.events scene:A pic + texts : options 1,2,3 exit
    //6.fight scene: players +enemies
    //7. where is the funny point?

    //class:
    //player:position,life,armor,attack,speed,strongRate,[fire,water,land,wind] ,turnToAttack:0 (attack after xxx turns)
    // attack effect: life -x% , turnToAttack + x, armor -x% ,attack -x% ,speed -x% ,strongRate -x%
    // [fire,water,land,wind]  
    // turn effect: (in a fight, when adding or minusing effect)
    // turn effect: [id ,turnLeft,turnToAttack,armor...][id ,turnLeft,turnToAttack,armor...]
    // normal attack:calculate from player class and turn effect class
    //att*fire - armor*fire   if(Math.random in strongRate) attack*2 ;attack= attack*position;(mid=1,front=1.2 behind=0.8)  
    //attack method: choose one, random [1-n], all the enemy




# unity










五、MonoBehaviour类

继承层次：Object->Component->Behaviour->MonoBehaviour

注意：复选框控件（在编辑中）仅仅会阻止Start、Awake、Update、FixedUpdate和OnGUI函数的执行，如果这些函数中没有一个出现，则复选框就不会显示。

调用方法Invoke（可用于延时）：

CancelInvoke() 取消在这个脚本上的所有调用

void Invoke(string methodName, float time)  在time时间内调用名字为methodName的函数

void InvokeRepeating(string methodName, float time, float repeatRate) 在time时间内调用名字为methodName的函数，此后每

repeatRate秒就调用一次该函数

bool IsInvoking() 该MonoBehaviour上是否有等候调用的函数

消息：


void Enable(); 只有object是激活状态下才可被调用，在object可用之后被调用，这通常发生于MonoBehaviour实例被创建时，不能做协程。 

void Start(); 如果脚本实例是enabled的，则Start函数在第一帧更新之前被调用，在脚本实例生命周期中仅被调用一次。不论脚本enabled与否，Awake函数都会调用；假如初始化期间脚本disabled，则Start函数就不会与Awake函数在同一帧中被调用。Awake函数和OnEnable函数一定是在Start函数之前调用（好处是：object A实例化代码依赖于object B实例化，B的实例化就应该在Awake阶段完成，A的实例化就在Start阶段完成）。注意：对于添加到场景中的objects，所有脚本的Start函数都会在任何脚本调用Update等函数之前被调用。但是，在gameplay期间实例化objects，就不能强制遵循这个规则了。

void OnDisable(); 当行为不可用或非激活时，该函数被调用。当对象被销毁时，或对于任何清理工作的代码，该函数同样可被调用。当编译完成之后重新加载脚本，该函数可被调用，脚本加载完成时调用OnEnable函数。该函数不可以做协程。 
void OnDestroy(); 在对象存在的最后一帧中，OnDestroy这个函数在所有帧更新之后被调用，该函数仅仅会在那些先前状态为active的对象上被调用。对象被销毁来响应Object.Destroy或关闭一个场景，该函数不可以是协程。

void FixedUpdate(); 假如MonoBehaviour是enabled时，该函数在固定帧率的每帧中被调用一次。比Update函数的调用更频繁；当帧率比较低时，每帧可被多次调用，如果帧率比较高，就可能不会被调用；所有的物理计算和更新都在FixedUpdate函数之后立即发生；当在FixedUpdate函数中计算物体移动时，不需要乘以Time.deltaTime，因为FixedUpdate函数是基于可靠的定时器，与帧率无关。 
void Update(); 假如MonoBehaviour是enabled时，该函数每帧被调用一次，是最主要最常用的帧更新函数。为了得到从上一帧调用Update函数到现在消耗的时间，需要使用Time.deltaTime。 
void LateUpdate(); 假如MonoBehaviour是enabled时，该函数每帧被调用一次，在Update函数之后执行；LateUpdate函数最常应用于第三人称的相机跟随。（如果将角色的移动和旋转放在Update函数中，则可以把相机的移动和旋转都放在LateUpdate函数，从而在相机追踪到角色位置之前，确保角色已经完成了移动。
注意：协程在所有Update函数完成后执行；若在LateUpdate中开启了一个协程，它将在LateUpdate之后渲染之前也会被调用。

void OnAnimatorIK(int layerIndex);动画组件在更新它内部Inverse Kinematics(IK)系统之前调用该函数。可用于设置IK目标位置和他们各自的权重。

void OnAnimatorMove(); 用于修改根运动而处理动画移动时调用。在状态机和动画计算完，OnAnimationIK之前，每帧都会被调用。

void OnAppllicationFocus(bool); 当玩家获得或失去焦点时，该消息被发送到所有游戏对象。该函数可以是协程，假如其作为协程来执行，在初始化帧期间会被用到两次：第一次用作前期消息通知，第二次发生在正常的协程更新步骤中。

void OnApplicationPause(bool); 当玩家暂停游戏，该消息会被发送给所有游戏对象。若暂停被检测到，当前帧执行后就调用OnApplicationPause函数，在正常的帧更新之间调用是有效的。在OnApplicationPause函数被调用后，增加额外的一帧来显示图像表明暂停状态。OnApplicationPause函数可以是协程，假如其作为协程来执行，在初始化帧期间会被用到两次：第一次用作前期消息通知，第二次发生在正常的协程更新步骤中。

void OnApplicationQuit(); 在应用退出之前所有的游戏对象都会调用该函数。在编辑器中当用户停止播放时它将被调用；在webplayer中，当网页关闭时被调用。注意，IOS应用通常暂停并不会退出，所以应该在IOS播放器设置中勾选“Exit on Suspend”，这样会使游戏退出而不是暂停。如果没有勾选就会调用OnApplicationPause函数。

void OnBecameInvisible();void OnBecameVisible(); 当object在任何相机中变得可见/不可见时被调用，该消息被发送到任何挂在渲染器上的脚本。使用这两个函数可以避免不必要的计算，仅当object可见时才进行相应的计算。它们可以是协程。当在编辑器中运行时，场景视图摄像机也会导致它们被调用。 

void OnCollisionEnter(Collision collision); 当该碰撞器/刚体开始接触到另一个刚体/碰撞器的时候，该函数被调用，可以做协程。和OnTriggerEnter函数相比，OnCollisionEnter的参数是Collision类而不是Collider。Collision类包含接触点，碰撞速度等信息，如果不需要在函数中使用这些碰撞信息，就不要考虑碰撞信息，这样可以避免不必要的计算。注意：碰撞事件仅仅当其中一个碰撞器中的也有一个non-kinematic刚体挂在时才会被发送。

void OnCollisionEnter2D(Collision2D collision); 当传进来的Collider和对象的Collider有接触时该函数被调用（仅限于2D物理）。

void OnCollisionExit(Collision collision); 当该碰撞器/刚体停止碰撞另一个刚体/碰撞器时被调用，可以做协程。和TriggerExit函数相比，OnCollisionExit 参数是Collision类而不是Collider。Collision类包含接触点，碰撞速度等信息，如果不需要在函数中使用这些碰撞信息，就不要考虑碰撞信息，这样可以避免不必要的计算。注意：碰撞事件仅仅当其中一个碰撞器中的也有一个non-kinematic刚体挂在时才会被发送。

void OnCollisionExit2D(Collision2D collision); 当传进来的Collider和对象的Collider停止接触时该函数被调用（仅限于2D物理）。

void OnCollisionStay(Collision collision); 对于每一个正在碰触其他刚体/碰撞器的碰撞器/刚体，该函数每帧都会被调用一次，可以做协程。和OnTriggerStay函数相比，OnCollisionStay参数是Collision类而不是Collider。Collision类包含接触点，碰撞速度等信息，如果不需要在函数中使用这些碰撞信息，就不要考虑碰撞信息，这样可以避免不必要的计算。注意：碰撞事件仅仅当其中一个碰撞器中的也有一个non-kinematic刚体挂在时才会被发送。

void OnCollisionExitStay2D(Collision2D collision); 当一个对象的Collider和这个对象的Collider正在碰撞时该函数被调用（仅限于2D物理）。

void OnControllerColliderHit(ControllerColliderHit); 当控制器执行时移动时碰到一个Collider上，该函数被调用。当它们碰撞到角色上时被用于推开对象。

void OnParticleCollision(GameObject); 当一个粒子撞到碰撞器上时该函数被调用。用于游戏对象受粒子碰撞时的伤害计算。

void OnConnectedToServer(); 当成功连接到服务器时客户端调用该函数。

void OnDisconnectedFromServer(NetworkDisconnection); 当与服务器连接中断或终止连接时，该函数被调用。

void OnFailedToConnect(); 由于某些原因尝试连接失败时，客户端调用该函数。

void OnFailedToConnectToMasterServer(NetworkConnectionError); 连接到主服务器有问题时服务器端或客户端调用该函数。

void OnMasterServerEvent(MasterServerEvent); 当收到来自主服务器报告事件，该函数被客户端或服务器端调用。

void OnServerInitialized(); 不论何时Network.InitializeServer被触发并完成，服务器会调用该函数。

void OnSerializeNetworkView(BitStream, NetworkMessageInfo); 用于定制脚本中变量的同步，从网络的视角来看。自动决定是否序列化的变量应该被发送或接收。

void OnPlayerConnected(NetworkPlayer); 不论何时玩家成功连接到服务器时，服务器端调用该函数。

void OnPlayerDisconnected(NetworkPlayer); 不论何时玩家与服务器失去连接时，服务器端调用该函数。

void OnNetworkInstantiate(NetworkMessageInfo); 使用Network.Instantiate，对象被网络实例化时被调用。

void OnPreCull(); 在相机剔除场景前被调用，剔除确定了哪些物体在相机中是可见的。仅当脚本挂在相机上并且是enabled时，该函数才会被调用。假如要修改相机的可视化参数（比如FOV，Transform等），就应该在这个函数中进行修改，此后场景中objects的可见性就取决于相机的参数了。

void OnWillRenderObject(); 如果物体可见并且MonoBehaviour是enabled时，在渲染每个经过剔除操作之后的物体之前，它将为每个相机调用一次。 

void OnPreRender(); 仅当脚本挂在相机上并且是enabled时，则在相机开始渲染场景之前被调用。假如在这个函数中修改了相机的可视化参数（比如FOV），那么这些参数只会在下一帧中起到作用。该函数可以是协程。 

void OnPostRender(); 在相机完成场景的渲染后被调用。与OnRenderObject不同，仅当脚本挂在相机上并且是enabled时，该函数才会被调用。该函数可以做协程。假如想要在所有相机和GUI渲染之后做操作，使用WaitForEndOfFrame协程。 

void OnRenderObject(); 在所有固定场景渲染之后被调用，此时你可以使用GL类函数或者Graphics.DrawMeshNow来画自定义的几何体。该函数和OnPostRender函数相似，除了一点：不论脚本挂在相机上与否，OnRenderObject函数都会在任何挂有定义了该函数的脚本的object上被调用。 

void OnRenderImage(RenderTexture， RenderTexture); 在场景渲染完成后被调用，用于对屏幕的图像进行后处理，该消息被发送到挂到相机上的所有脚本。该函数允许利用基于shader的过滤器对最终图像进行处理，传入源渲染纹理，终止于目标渲染纹理；当相机有多个图像过滤器时，按照图像顺序进行处理，前一个过滤器的目标渲染纹理作为下一个过滤器的源渲染纹理。

void OnGUI(); 假如MonoBehaviour是disabled时，该函数不会被调用。为响应GUI事件，该函数每帧被调用多次，每个事件就调用一次；执行时先响应布局和重绘事件，随后是为每一次的输入事件执行布局和键盘/鼠标事件。

void OnDrawGizmos(); 为了可视化的目的，在场景视图中绘制小图标。该函数使用相对于Scene视图的鼠标的位置，允许快速挑选场景中重要的objects，当然假如组件在inspector中collapsed，则该函数就不会被调用。 
void OnDrawGizmosSelected(); 同OnDrawGizmos，不过只有选中的物体执行。

void OnMouseEnter(); 当鼠标进入GUIElement或Collider时该函数被调用，该消息会被发送给Collider或GUIElement的所有脚本。该函数不能被属于忽略Raycast layer的对象来调用。可以做协程。

void OnMouseExit(); 当鼠标离开GUIElement或Collider时该函数被调用，该消息会被发送给Collider或GUIElement的所有脚本。该函数不能被属于忽略Raycast layer的对象来调用。可以做协程。

void OnMouseDown(); 当用户在GUIElement或Collider上按下鼠标时该函数被调用，该消息会被发送给Collider或GUIElement的所有脚本。该函数不能被属于忽略Raycast layer的对象来调用。可以做协程。

void OnMouseUp(); 当用户释放鼠标按键时，该函数被调用，即使鼠标已经不在和鼠标按下相同的一个GUIElement或Collider上时该函数被调用。可以做协程，该消息会被发送给Collider或GUIElement的所有脚本。该函数不能被属于忽略Raycast layer的对象来调用。

void OnMouseUpAsButton(); 当用户释放鼠标按键时，该函数被调用，只在和鼠标按下相同的一个GUIElement或Collider上时该函数被调用。可以做协程，该消息会被发送给Collider或GUIElement的所有脚本。该函数不能被属于忽略Raycast layer的对象来调用。

void OnMouseDrag(); 当用户在GUIElement或Collider上点击鼠标并一直按着时该函数被调用，按着鼠标的每一帧中该函数都会被调用，可以做协程，该消息会被发送给Collider或GUIElement的所有脚本。该函数不能被属于忽略Raycast layer的对象来调用。

void OnMouseOver(); 当鼠标在GUIElement或Collider上时该函数被调用，按着鼠标的每一帧中该函数都会被调用，可以做协程，该消息会被发送给Collider或GUIElement的所有脚本。该函数不能被属于忽略Raycast layer的对象来调用。

void OnTriggerEnter(Collider); 当碰撞器进入触发器时该函数被调用。该消息被发送给触发器碰撞器和碰到触发器的刚体（假如没有刚体就是碰撞器），但只有在其中一个碰撞器也有刚体挂载时，触发事件才会被发送。该函数可以做协程。

void OnTriggerEnter2D(Collider2D); 当另一个对象碰到这个对象上挂有的触发器碰撞器时，该消息被发送（仅仅2D物理适用）。

void OnTriggerExit(Collider); 当另一个碰撞器停止碰撞该触发器时该函数被调用。该消息被发送给触发器和碰撞触发器的碰撞器。注意，只有在其中一个碰撞器也有刚体挂载时，触发事件才会被发送。该函数可以做协程。

void OnTriggerExit2D(Collider2D); 当另一个对象离开这个对象上挂有的触发器碰撞器时，该消息被发送（仅仅2D物理适用）。

void OnTriggerStay(Collider); 对于每一个正在碰撞该触发器的碰撞器，该函数每帧被调用一次。该消息会被发送给触发器和碰撞该触发器的碰撞器，注意，只有在其中一个碰撞器也有刚体挂载时，触发事件才会被发送。该函数可以做协程。

void OnTriggerStay2D(Collider2D); 当另一个对象在该对象的触发器碰撞器内时该函数每帧被都会被调用。（仅仅2D物理适用）

void OnJointBreak(float);  当连接到同一游戏对象上的关节断裂时被调用。当外力高于关节的breakForce时，关节会断开。当关节断开时，该函数被调用，施加于关节处的断裂外力会被做为参数传入。当该函数完成后，关节会自动从游戏对象上移除。

六、Mathf类

Mathf.Abs  绝对值    计算并返回指定参数 f 绝对值。 

Mathf.Acos 反余弦 
static function Acos (f : float) : float     以弧度为单位计算并返回参数 f 中指定的数字的反余弦值。 

Mathf.Approximately近似 
static function Approximately (a : float, b: float) : bool     比较两个浮点数值，看它们是否非常接近, 由于浮点数值不精确，不建议使用等于来比较它们。例如，1.0==10.0/10.0也许不会返回true。 

Mathf.Asin反正弦 
static function Asin (f : float) : float     以弧度为单位计算并返回参数 f 中指定的数字的反正弦值。 

Mathf.Atan2反正切 
static function Atan2 (y : float, x :float) : float      以弧度为单位计算并返回 y/x 的反正切值。返回值表示相对直角三角形对角的角，其中 x 是临边边长，而 y 是对边边长。 
返回值是在x轴和一个二维向量开始于0个结束在(x,y)处之间的角。 

Mathf.Atan反正切 
static function Atan (f : float) :float      计算并返回参数 f 中指定的数字的反正切值。返回值介于负二分之 pi 与正二分之 pi 之间。 

Mathf.CeilToInt最小整数 
static function CeilToInt (f : float) : int     返回最小的整数大于或等于f。 

Mathf.Ceil上限值 
static function Ceil (f : float) : float      返回 f 指定数字或表达式的上限值。数字的上限值是大于等于该数字的最接近的整数。 

Mathf.Clamp01限制0~1 
static function Clamp01 (value : float) :float     限制value在0,1之间并返回value。如果value小于0，返回0。如果value大于1,返回1，否则返回value 。 

Mathf.Clamp限制 
static function Clamp (value : float, min :float, max : float) : float     限制value的值在min和max之间， 如果value小于min，返回min。 如果value大于max，返回max，否则返回value 
static function Clamp (value : int, min :int, max : int) : int        限制value的值在min和max之间，并返回value。 

Mathf.ClosestPowerOfTwo最近的二次方 
static function ClosestPowerOfTwo (value :int) : int      返回距离value最近的2的次方数。 

Mathf.Cos余弦 
static function Cos (f : float) : float      返回由参数 f 指定的角的余弦值（介于 -1.0 与 1.0 之间的值）。 

Mathf.Deg2Rad度转弧度 
static var Deg2Rad : float     度到弧度的转化常量。（只读）    这等于(PI * 2) / 360。 

Mathf.Mathf.Rad2Deg 弧度转度 
static var Rad2Deg : float    弧度到度的转化常量。（只读）    这等于 360 / (PI * 2)。 

Mathf.DeltaAngle增量角 
static function DeltaAngle (current :float, target : float) : float      计算给定的两个角之间最短的差异。 

Mathf.Epsilon小正数 
static var Epsilon : float    一个很小的浮点数值。（只读）    最小的浮点值，不同于0。 
以下规则： 
-    anyValue + Epsilon = anyValue 
-    anyValue - Epsilon = anyValue 
-    0 + Epsilon = Epsilon 
-    0 - Epsilon = -Epsilon 
一个在任意数和Epsilon的之间值将导致在任意数发生截断误差。 

Mathf.Exp指数 
static function Exp (power : float) : float     返回 e 的 power 次方的值。 

Mathf.FloorToInt最大整数 
static function FloorToInt (f : float) :int     返回最大的整数，小于或等于f。 

Mathf.Floor下限值 
static function Floor (f : float) : float      返回参数 f 中指定的数字或表达式的下限值。下限值是小于等于指定数字或表达式的最接近的整数。 

Mathf.Infinity正无穷 
static var Infinity : float      表示正无穷，也就是无穷大，∞ （只读） 

Mathf.InverseLerp反插值       计算两个值之间的Lerp参数。也就是value在from和to之间的比例值。 

Mathf.IsPowerOfTwo是否2的幂 
static function IsPowerOfTwo (value : int): bool      如果该值是2的幂，返回true。 

Mathf.LerpAngle插值角度 
static function LerpAngle (a : float, b :float, t : float) : float      和Lerp的原理一样，当他们环绕360度确保插值正确。   a和b是代表度数。 

Mathf.Lerp插值 
static function Lerp (from : float, to :float, t : float) : float     基于浮点数t返回a到b之间的插值，t限制在0～1之间。      当t = 0返回from，当t = 1 返回to。当t = 0.5 返回from和to的平均值。 

Mathf.Log10基数10的对数 
static function Log10 (f : float) : float     返回f的对数，基数为10。 

Mathf.Log对数 
static function Log (f : float, p : float): float     返回参数 f 的对数。 

Mathf.Max最大值 
static function Max (a : float, b : float): float 
static function Max (params values :float[]) : float 
返回两个或更多值中最大的值。 

Mathf.Min最小值 
static function Min (a : float, b : float): float 
static function Min (params values :float[]) : float 
返回两个或更多值中最小的值。 

Mathf.MoveTowardsAngle移动角 
static function MoveTowardsAngle (current :float, target : float, maxDelta : float) : float 
像MoveTowards,但是当它们环绕360度确保插值正确。 
变量current和target是作为度数。为优化原因，maxDelta负值的不被支持，可能引起振荡。从target角推开current，添加180度角代替。 

Mathf.MoveTowards移向 
static function MoveTowards (current :float, target : float, maxDelta : float) : float 
改变一个当前值向目标值靠近。 
这实际上和 Mathf.Lerp相同，而是该函数将确保我们的速度不会超过maxDelta。maxDelta为负值将目标从推离。 

Mathf.NegativeInfinity负无穷 
static var NegativeInfinity : float      表示负无穷，也就是无穷小，-∞（只读） 

Mathf.NextPowerOfTwo下个2的幂 

Mathf.PingPong乒乓 
static function PingPong (t : float, length: float) : float 
0到length之间往返。t值永远不会大于length的值，也永远不会小于0。 
The returned value will move back and forthbetween 0 and length. 
返回值将在0和length之间来回移动。 

Mathf.PI圆周率 
static var PI : float      PI（读pai）的值，也就是圆周率（π）的值3.14159265358979323846...（只读） 

Mathf.Pow次方 
static function Pow (f : float, p : float): float     计算并返回 f 的 p 次方。 

Mathf.Repeat重复 
static function Repeat (t : float, length :float) : float 
循环数值t，0到length之间。t值永远不会大于length的值，也永远不会小于0。     这是类似于模运算符，但可以使用浮点数。 

Mathf.RoundToInt四舍五入到整数 
static function RoundToInt (f : float) :int 
返回 f 指定的值四舍五入到最近的整数。      如果数字末尾是.5，因此它是在两个整数中间，不管是偶数或是奇数，将返回偶数。 

Mathf.Round四舍五入 
static function Round (f : float) : float 
返回浮点数 f 进行四舍五入最接近的整数。      如果数字末尾是.5，因此它是在两个整数中间，不管是偶数或是奇数，将返回偶数。 

Mathf.Sign符号 
static function Sign (f : float) : float      返回 f 的符号。     当 f 为正或为0返回1，为负返回-1。 

Mathf.Sin正弦 
static function Sin (f : float) : float       计算并返回以弧度为单位指定的角 f 的正弦值。 

Mathf.SmoothDampAngle平滑阻尼角度 
static function SmoothDampAngle (current :float, target : float, ref currentVelocity : float, smoothTime : float,maxSpeed : float = Mathf.Infinity, deltaTime : float = Time.deltaTime) : float 
参数 
current 
当前的位置。 
target 
我们试图达到的位置。 
currentVelocity 
当前速度，这个值在你访问这个函数的时候会被随时修改。 
smoothTime 
the target faster. 
要到达目标位置的近似时间，实际到达目标时要快一些。 
maxSpeed 
可选参数，允许你限制的最大速度。 
deltaTime 
上次调用该函数到现在的时间。缺省为Time.deltaTime。 
随着时间的推移逐渐改变一个给定的角度到期望的角度。 
这个值通过一些弹簧减震器类似的功能被平滑。这个函数可以用来平滑任何一种值，位置，颜色，标量。最常见的是平滑一个跟随摄像机。 

Mathf.SmoothDamp平滑阻尼 
static function SmoothDamp (current :float, target : float, ref currentVelocity : float, smoothTime : float,maxSpeed : float = Mathf.Infinity, deltaTime : float = Time.deltaTime) : float 
参数 
current 
当前的位置。 
target 
我们试图达到的位置。 
currentVelocity 
当前速度，这个值在你访问这个函数的时候会被随时修改。 
smoothTime 
要到达目标位置的近似时间，实际到达目标时要快一些。 
maxSpeed 
可选参数，允许你限制的最大速度。 
deltaTime 
上次调用该函数到现在的时间。缺省为Time.deltaTime。 
描述 
随着时间的推移逐渐改变一个值到期望值。 
这个值就像被一个不会崩溃的弹簧减振器一样被平滑。这个函数可以用来平滑任何类型的值，位置，颜色，标量。

Mathf.SmoothStep平滑插值 
static function SmoothStep (from : float,to : float, t : float) : float 
和lerp类似，在最小和最大值之间的插值，并在限制处渐入渐出。 

Mathf.Sqrt平方根 
static function Sqrt (f : float) : float      计算并返回 f 的平方根。 

Mathf.Tan正切 
static function Tan (f : float) : float      计算并返回以弧度为单位 f 指定角度的正切值。

七、Quaternion类

常用变量：

identity    不旋转

eulerAngles     将四元数转换成欧拉角

常用方法：

Euler    将欧拉角转换成四元数

LookRotation    设置朝向

            Vector3 dir = enemy.position - player.position;
            dir.y = 0;
            player.rotation= Quaternion.LookRotation(dir);  //设置Player朝向Enemy
Slerp      插值（适用于球形有弧度或角度的插值）
            Vector3 dir = enemy.position - player.position;
            dir.y = 0;
            Quaternion target = Quaternion.LookRotation(dir);
            player.rotation = Quaternion.Slerp(player.rotation, target, Time.deltaTime);
八、Rigidbody
position              如果使用Rigidbody.position更改Rigibody的位置，则在下一个物理模拟步骤之后将会更新Transform。这比使用Transform.position更新位置要快，因为后者将导致所有附加的Colliders重新计算它们相对于Rigidbody的位置。如果想连续移动一个刚体，使用MovePosition来代替。

MovePosition     调用Rigidbody.MovePosition会导致渲染的任何中间帧中两个位置之间的平滑过渡。如果要在每个FixedUpdate中连续移动刚体，则应该使用此选项。    如果想将一个刚体从一个位置直接传送到另一个位置，不需要渲染中间位置，使用position设置位置。       如果刚体is Kinematic设置为false，调用Rigidbody.MovePosition还是会将一个刚体从一个位置直接传送到另一个位置。


playerRigidbody.position = playerRigidbody.position + Vector3.forward * Time.deltaTime * 100;//使用Rigidbody.position更改Rigibody的位置
playerRigidbody.MovePosition(playerRigidbody.position + Vector3.forward * Time.deltaTime * 100);//使用MovePosition来代替rotation
rotation、MoveRotation和以上相同。
AddForce    给刚体添加一个力（指定方向和大小）。

九、Application

dataPath   包含游戏数据文件夹的路径，不同平台路径不同。

streamingAssetsPath    在Unity项目的Assets下创建streamingAssets文件夹，保存包括视频、音频、AssetBundle资源，这些资源不会被打包。

http://blog.csdn.net/u011325034/article/details/49327225

http://www.jianshu.com/p/617789c9919a

https://www.cnblogs.com/colve/p/5149847.html

.........

十、SceneManager 

sceneCount场景的总数。

sceneCountInBuildSettings在BuildSettings中的场景数量。

CreateScene     创建一个空的新场景并指定名称。

GetActiveScene获取激活的场景。

GetSceneAt获取在场景管理列表添加场景的索引。

GetSceneByName    通过场景添加到场景管理器的指定名称查找该场景。

GetSceneByPath  查找所有给定资源路径并添加到SceneManager中的场景。

LoadScene 通过在Build Settings中它们的名称或索引加载场景。

LoadSceneAsync  在后台异步加载场景。

MergeScenes       该属性将场景资源合并到destinationScene。该函数合并场景资源内容到目的场景并删除原场景资源。所有根资源场景下的物体移动到根目的场景目录下。注意：该函数是有破坏性的：当资源合并完成后原有资源场景将会被立刻销毁。

MoveGameObjectToScene  移动一个物体从它当前场景到一个新的场景中。它必须要求该物体在当前场景的根目录下。

SetActiveScene  设置被激活的场景。

UnloadScene   卸载所有和指定场景关联的物体。









transform类是Unity脚本编辑的一个基础且重要的类，所以我们下面一起来学习一下这个类。

一、成员变量
position：在世界空间坐标transform的位置。
localPosition：相对于父级的变换的位置。如果该变换没有父级，那么等同于Transform.position。
eulerAngles：世界坐标系中的旋转（欧拉角）。
localEulerAngles：相对于父级的变换旋转角度。
right：世界坐标系中的右方向。（世界空间坐标变换的红色轴。也就是x轴。）
up：世界坐标系中的上方向。（在世界空间坐标变换的绿色轴。也就是y轴。）
forward：世界坐标系中的前方向。（在世界空间坐标变换的蓝色轴。也就是z轴。）
rotation：世界坐标系中的旋转（四元数）。
localRotation：相对于父级的变换旋转角度。
localScale：相对于父级的缩放比例。
parent：父对象Transform组件。
worldToLocalMatrix：矩阵变换的点从世界坐标转为自身坐标（只读）。
localToWorldMatrix：矩阵变换的点从自身坐标转为世界坐标（只读）。
root：对象层级关系中的根对象的Transform组件。
childCount：子对象数量。
lossyScale：全局缩放比例（只读）。

二、函数
1）Translate，用来移动物体的函数，非常常用的一个函数。
public void Translate (translation : Vector3, relativeTo : Space = Space.Self) : void
把物体向translation方向移动，距离为translation.magnitude。 relativeTo表示这个移动的参考坐标系。

public void Translate (x : float, y : float, z : float, relativeTo : Space = Space.Self) : void
同上

public void Translate (translation : Vector3, relativeTo : Transform) : void
如果relativeTo 不是null，则以目标物体relativeTo的自身轴向作为参考坐标系。

public void Translate (x : float, y : float, z : float, relativeTo : Transform) : void
同上

脚本：

var speed=30；

//将物体以30米每秒的速度向前移动。

trasform.Translate(Vector3.forward*speed*Time.deltaTime);

 

2）Rotate，用来旋转物体的函数，非常常用，在知道需要旋转的角度的情况下。如果要让物体旋转到指定位置，需要搭配Quaternion来使用。
public void Rotate (eulerAngles : Vector3, relativeTo : Space = Space.Self) : void
旋转eulerAngles度（3个轴向分别旋转），以relativeTo为参考坐标系

public void Rotate (xAngle : float, yAngle : float, zAngle : float, relativeTo : Space = Space.Self) : void
同上

public void Rotate (axis : Vector3, angle : float, relativeTo : Space = Space.Self) : void
以axis为轴旋转angle度，以relativeTo为参考坐标系

 

3）RotateAround 让物体以某一点为轴心成圆周运动。
public void RotateAround (point : Vector3, axis : Vector3, angle : float) : void
让物体以point为中心，绕axis为轴向旋转angle度。保持原来与point的距离。

 

4）LookAt 让物体的z轴看向目标物体
public void LookAt (target : Transform, worldUp : Vector3 = Vector3.up) : void
让物体的z轴看向target的位置,并以worldUp为y轴指向方向。

public void LookAt (worldPosition : Vector3, worldUp : Vector3 = Vector3.up) : void
让物体看向worldPosition

 

5)TransformDirection
public Vector3 TransformDirection (direction : Vector3) : Vector3
返回以物体自身为坐标轴的向量direction在世界坐标中的朝向向量。

public Vector3 TransformDirection (x : float, y : float, z : float) : Vector3
同上

 

6）InverseTransformDirection
public Vector3 InverseTransformDirectionTransformDirection (direction : Vector3) : Vector3
public Vector3 InverseTransformDirectionTransformDirection (x : float, y : float, z : float) : Vector3
与TransformDirection相反，从世界坐标转换到自身相对坐标。

 

7）TransformPoint
public Vector3 TransformPoint (position : Vector3) : Vector3
public Vector3 TransformPoint (x : float, y : float, z : float) : Vector3
把一个点从自身相对坐标转换到世界坐标

 

8）InverseTransformPoint
public Vector3  InverseTransformPoint (position : Vector3) : Vector3
public Vector3  InverseTransformPoint (x : float, y : float, z : float) : Vector3
把一个点从时间坐标转换到自身坐标的位置。

 

9）DetachChildren
public void DetachChildren () : void
把自身所有的子物体的父物体都设成世界，也就是跟自己的所有子物体接触父子关系。

 

10）Find
public Transform Find (name : string) : Transform
找到一个名字是name的物体并返回

如果没有找到则返回null。如果字符串被/隔离，函数则会像文件路径一样逐级下查。

// The magical rotating finger
function Update() {
aFinger = transform.Find("LeftShoulder/Arm/Hand/Finger");
aFinger.Rotate(Time.deltaTime*20, 0, 0);
}

 

11)IsChildOf
public bool IsChildOf (parent : Transform) : bool
如果物体是parent的父子层级关系下的一员，返回true;




World Space（世界坐标）：我们在场景中添加物体（如：Cube），他们都是以世界坐标显示在场景中的。transform.position可以获得该位置坐标。

World世界坐标：从前视图front看：
·X轴正方向指向（屏幕）右侧。
·Z轴正方向指向（屏幕）上方。
·Y轴正方向背离你。           

Screen Space（屏幕坐标）:以像素来定义的，以屏幕的左下角为（0，0）点，右上角为（Screen.width，Screen.height），Z的位置是以相机的世界单位来衡量的。注：鼠标位置坐标属于屏幕坐标，Input.mousePosition可以获得该位置坐标，手指触摸屏幕也为屏幕坐标，Input.GetTouch(0).position可以获得单个手指触摸屏幕坐标。

Screen屏幕坐标：使用激活的视口屏幕作为坐标系。
·X轴是水平的，正方向指向（屏幕）右侧。
·Y轴是垂直的，正方向指向（屏幕）上方。
·Z轴是进深的，正方向指向你。
因为屏幕坐标模式是以激活视口作为它的坐标方向，未激活视口中轴三脚架上X，Y，Z的指向显示当前激活视口的方向。当你激活这个视口时，轴三脚架上的指向将会改变。

ViewPort Space（视口坐标）:视口坐标是标准的和相对于相机的。相机的左下角为（0，0）点，右上角为（1，1）点，Z的位置是以相机的世界单位来衡量的。

 View视图坐标：在默认坐标系下，在所有的（正交）视图中X，Y，Z三个轴是相同的。当你使用这个坐标系移动一个对象时，你所移动的对象与视口空间有如下关系。
·X轴总是指向（屏幕）右侧。
·Y轴总是指向（屏幕）上方。
·Z轴总是垂直屏幕指向你。

绘制GUI界面的坐标系：这个坐标系与屏幕坐标系相似，不同的是该坐标系以屏幕的左上角为（0，0）点，右下角为（Screen.width，Screen.height）。

• 世界坐标→屏幕坐标：camera.WorldToScreenPoint(transform.position);这样可以将世界坐标转换为屏幕坐标。其中camera为场景中的camera对象。

• 屏幕坐标→视口坐标：camera.ScreenToViewportPoint(Input.GetTouch(0).position);这样可以将屏幕坐标转换为视口坐标。其中camera为场景中的camera对象。






通常使用刚体与碰撞体共同构成人物移动的物理系统。

有这么几点需要注意：

1、动态刚体一旦与一个没有弹性的碰撞体碰撞了后，那么其速度立刻变为0，并且不会反弹回来，没有其他操作，其速度一直为0，并且只有动态刚体才能与其他的碰撞体发生反应，调用OnColliderEnter和OnTriggerEnter。

2、动态刚体使用AddForce，它真的应用了物理模拟。也就是说，F*S=0.5*m*V^2。只要你一直给它加力，那么这个动态刚体就会一直获得动能，它的速度就会一直加快。如果没有设置线性阻尼，没有与groud的摩擦力，那么这个物体就会一直匀速直线运动。所以真的很真实。需要注意，摩擦力这个是需要在物理材质中进行设置的。

3、Unity物理系统的碰撞检测是离散的，是按固定间隔0.02秒进行检测（其他的所有物理行为都是按固定间隔进行计算的，但是这个间隔是可以在Editor中设置的。还有我们要注意Update的帧间隔，与固定0.02秒的物理间隔的关系。嗯~ o(*￣▽￣*)o，他们的关系就是没有关系。因为他们不属于一个次元。但是我们要明白，Update的帧间隔在机器性能差的时候会影响到Unity物理系统，严重时会使物理系统瘫痪掉，也就是无法进行各种计算。各种各样的奇怪情况。）具体的情况参考https://blog.csdn.net/mao_xiao_feng/article/details/52605370

 

Rigidbody2D详解
一些事项：

1.任何添加到同一个 GameObject身上或者其子物体身上的 2D Collider组件都隐式的 附属于 那个 Rigidbody 2D.

2.当一个Collider 2D组件附属到一个Rigidbody 2D身上时，它就跟随Rigidbody 2D移动。这时不应该通过直接设置Transform 或者 Collider的偏移量来 移动。

3.附属于同一个 Rigidbody 2D的所有 Collider 2D，它们相互是不会发生碰撞检测的。

 

刚体类型：

1. Rigidbody 2D 有三个类型：Dynamic、Kinematic、Static

2. 刚体类型主要影响一下几个要素：

　　a. 移动行为(位置、旋转)

　　b. 碰撞体交互

3. 注意一点，虽然Rigidbody 经常被描述成 是与其它 rigidbody 相互碰撞，但是实际上是 附加在Rigidbody上的Collider在进行碰撞检测，Rigidbody在没有Collider的情况下，是没法相互碰撞的。

4. 改变Rigidbody 2D的类型是一个比较麻烦的事情。当一个刚体类型改变，许多关联的变量会立马重置，并且需要重新赋值，而且与刚体关联的所有Collider需要在下一个FixiedUpdate之前重新认知，这样可能会导致奇怪的表现。

 

刚体类型： Dynamic


概括来说，这种类型是为了 物理仿真运动而设计的。（让物体看起来更像现实世界行为）它的运动受重力、质量、摩擦力、其他力影响。并且这种类型会与其他所有刚体类型发生碰撞。代码适宜使用AddForce，Velocity进行移动。

通常我们设置Linear Drag（线性阻力）为0，但是这个物体跑着跑着还是会停止是因为它与别的碰撞体有摩擦力。

Simulated：该组件是否与仿真模拟交互。
Collision Detection：碰撞体之间的碰撞检测方式：
Discrete：在一个 物理更新期间，物理可以相互重叠、穿越。当速度太快时，碰撞只会在最新的位置检测，这就意味着，如果速度太快，使用这个选项会有问题。
Continuous：这个就不会存在Discete的问题，但是CPU消耗高。
Sleeping Model：在什么情况下，会休眠以节省性能。
Never Sleep：从不休眠
Start Awake：物体最初是醒着的
Start Asleep：物体最初是休眠的，但是遇到碰撞就会苏醒。
Interpolate：在物理更新中，物体移动的插值算法
None：
Interpolate：基于上一帧物体位置来插值模拟
Extrapolate：基于预测下一阵物体位置来插值模拟
刚体类型：Kinematic


这种类型，物体移动也是在仿真下进行的，但是却是在 用户非常明确的控制 的前提下进行的。也就是你要自己编写程序控制这个类型的刚体移动。它不会收到任何力的作用，但是它会与动态刚体发生碰撞，碰撞的表现为 动态刚体被他撞飞了，而自己不会动。 如果勾选Use Full Kinematic Contact选项，那么这个运动刚体会与其他的碰撞体进行碰撞。

注意

　　1. 这种类型不受力、重力的影响

　　2. 它使用Rigidbody2D.MovePosition or Rigidbody2D.MoveRotation API来移动。

　　3. 它使用物理引擎来查询 碰撞，并且通过编程来决定物体如何移动。

　　4. 实际上，这种类型仍然通过它的速度来移动，但是它的速度却不受其他任何力的影响。

　　5. 这种类型 不会 与其它Kinematic或者Static类型发生碰撞检测

　　6. 在碰撞过程中，这种类型的物体表现为不受力（质量无穷大）。

Simulated：如果想要在运行时 与其它Collider 2D 发生物理仿真交互，就打开它。

Use Full Kinematic Constacts：开启它，该物体就可以与其它任意类型的Rigidbody 2D发生碰撞。

 

刚体类型：Static


1. 它只与 Dynamic 类型的Rigidbody 发生碰撞.

2. 无法拥有两个 Static 的Rigidbody 2D。

 

 

常用API
AddForce：这个方法是真实地给物体施加力。等同于动能方程。我的按键必须持续的按下，它才能持续的给物体施加力，增加物体的速度。如果是kinematic的刚体类型，则这个施加力是无效的。

 

Velocity：这个就是刚体的速度属性，当刚体加力或者被撞飞的时候，就会有速度。当然我们也可以直接赋值是刚体具有速度来移动。

 

MovePosition：这个就是直接改变刚体的位置。通常在Kinematic类型使用。

MoveRotation：同上

 

除此之外，刚体组件还有一些方法很常用，我来列出。

AddForceAtPosition

Cast：计算被这个刚体所统领（所属物体的）的所有碰撞体按指定方向，指定距离进行射线检测，然后将射线的信息获取。

IsTouchingCollider() ：传入一个碰撞体的引用，判断该碰撞提与我的刚体是否接触。

OverlapPoint：输入一个position，看刚体是否与这个点重叠。

OverlapCollider：输入一个碰撞体，看刚体是否与这个碰撞体重叠。

GetContacts：获得所有与刚体接触的碰撞体。好棒~


Velocity
collider
rigidbody
Kinematic




Unity 3D 的物理组件为游戏开发者提供了碰撞体组件。碰撞体是物理组件的一类，它与刚体一起促使碰撞发生。
碰撞体是简单形状，如方块、球形或者胶囊形，在 Unity 3D 中每当一个 GameObjects 被创建时，它会自动分配一个合适的碰撞器。

一个立方体会得到一个 Box Collider（立方体碰撞体），一个球体会得到一个 Sphere Collider（球体碰撞体），一个胶囊体会得到一个 Capsule Collider（胶囊体碰撞体）等。

在 Unity 3D 的物理组件使用过程中，碰撞体需要与刚体一起添加到游戏对象上才能触发碰撞。
值得注意的是，刚体一定要绑定在被碰撞的对象上才能产生碰撞效果，而碰撞体则不一定要绑定刚体。



从GameObject上获取脚本:
可以将多个自定义脚本附加到同一个 GameObject。如果需要从一个脚本访问另一个脚本，可以像往常一样使用 GetComponent，只需使用脚本类的名称（或文件名）来指定所需的组件类型

例子：
加载一个prefab 的intance ,从instance中获取它的脚本组件的实例，然后执行实例.render()
GameObject instance = (GameObject)Instantiate(Resources.Load(type), transform.position, canvas.transform.rotation);


roleDisplay pane = (roleDisplay)instance.GetComponent(typeof(roleDisplay));
pane.render(role);



使用 Transform.Find 方法按名称查找特定子对象： transform.Find("Frying Pan");
player = GameObject.Find("MainHeroCharacter");


Destroy(gameObject, 0.5f);
该方法将在帧更新完成后或（可选）短时间延迟后销毁对象;


在一个xxx.cs中
this表示的是脚本实例，而不是GameObject实例




Unity 在 UnityEngine 命名空间中有一个名为 Object 的类，作为 Unity 可以在编辑器中引用的所有对象的基类

注意：Unity 的 Object 类位于 UnityEngine 命名空间。它与 .NET 的 Object 基类不同，虽然名称相同，但后者位于 System 命名空间，并且不包含在默认脚本模板中，因此名称不会发生冲突。如果您想在脚本中创建不需要在 Inspector 中指定的类，仍然可以从 .NET 的 System.Object 继承。


transform :游戏对象始终附加一个transform组件，无法删除transform组件或创建没有transform组件的游戏对象

变换组件的位置、旋转和缩放值是相对于变换组件的父项测量的。如果变换组件没有父项，则按照世界空间来测量属性。